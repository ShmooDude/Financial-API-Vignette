---
title: "financial-api-vignette"
output: github_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)
```

# Financial API and Exploratory Data Analysis



# Requirements

The following libraries are required to use the Financial API

* `tidyverse`: Many useful functions.
* `jsonlite`: Convert JSON into usable data
* `httr`: To get the information from the polygon API
* `memoise`: To prevent repeated calls to the API for the same information
* `lubridate`: For easier handling of date/time.
* `ratelimitr`: Limits the query rate to the API below the required 5 per minute

```{r, echo = FALSE}
library(tidyverse)
library(jsonlite)
library(httr)
library(memoise)
library(lubridate)
library(ratelimitr)
apiKey <- "To187CFZpgDYlj0_gWheNbOaw4MxRzvh"
```

# API Interaction Functions

## Helper Functions

### `getFromJSON`

Utilizes `GET` and `fromJSON` to retrieve a JSON type object and convert it into something usable.  Uses `memoise` to prevent repeated queries to the API for the same information.

```{r}
# Limit the rate at which the GET function can be called due to API limits
limGET <- limit_rate(GET, rate(n = 5, period = 60))

getFromJSON_fun <- function(URL = "https://api.polygon.io", path, query = list()) {
  # Create query list
  query$apiKey = apiKey
  
  # Get the results from the server
  results <- limGET(URL, path = path, query = query)

  # Convert from a JSON
  content <- rawToChar(results$content) %>% 
    fromJSON()
  
  # Continue getting information until finished
  while(exists("next_url", content)) {
    results <- limGET(content$next_url, query = query)

    new_content <- rawToChar(results$content) %>%
      fromJSON()

    append(content, new_content)
  }
  
  return(content)
}
getFromJSON <- memoise(getFromJSON_fun)
```


### `getTickerTypes`

This function gets the proper ticker type values to use in queries.  Functionality from `memoise` package is used here so that information only need to be looked up once.

```{r}
# Helper function to build the URL
getTickerTypes <- function() {
  # Retrieve JSON from the api 
  content <- getFromJSON(path = "/v3/reference/tickers/types")
  
  # Create lookup table
  output <- tolower(content$results$description)
  names(output) <- tolower(content$results$code)
  
  # Return the output
  return(output)
}
```

### `getTickers`

This function returns the proper ticker based on the search parameter and the type of ticker.  Could be expanded with other optional parameters of the Tickers Reference Data Endpoint.

```{r}
# Helper function to query$search for symbol
getTickers <- function(search, type = "", 
                       market = c("", "stocks", "crypto", "fx", "otc")) {
  # Storage for options to be passed to the API
  query <- list(search = search)
  query$market <- match.arg(market)
  
  # Check if valid optional parameters were entered
  # Currently supported: type
  
  # type should match one of the types in getTickerTypes
  if (type != "") {
    # Get the valid ticker types
    types <- getTickerTypes()
    
    # Check if the type is an code or a description
    if (type %in% names(types)) {
      # type is already a code
      query$type <- type
    } 
    else {
      # Check if type is a description
      if (type %in% types) {
        # use look up table to get correct code form description
        query$type <- types[type]
      }
      else {
        # type is neither a code or a description so throw an error
        stop(paste0(type, " is not a valid type"))
      }
    }
  }

  # Retrieve the information on the ticker(s)
  content <- getFromJSON(path = "/v3/reference/tickers",
                             query = query)
  
  # Check for zero or multiple results
  if (is_empty(content$results)) {
    message <- paste0("No tickers mateched \"", query$search, "\"")
    stop(message)
  } 
  else if (length(content$results$ticker) > 1) {
    # Check for an exact match to a ticker, case insensitive
    if (tolower(content$results$ticker) == tolower(query$search)) {
      return(content$results$ticker)
    } 
    else {
      message <- paste0("Multiple tickers matched \"", 
                      query$search, "\":\n", toString(content$results$ticker),
                      "\n", toString(content$results$name))
      stop(message)
    }
  }
  else {
    return(content$results$ticker)
  }
}
```

### `getTickerName`

This function returns the name of a particular ticker.

```{r}
getTickerName <- function(search) {
  # Retrieve the proper ticker for the search query
  ticker <- getTickers(search)
  
  # Retrieve the detailed information on the ticker
  output <- getFromJSON(path = paste0("/v3/reference/tickers/", ticker))
  
  unlist(output$results[[2]])
}
```

## Main Function

### `getAggregates`

Takes a particular ticker retrieves the pricing information for the date span specified.  Dates should be formatted `YYYY-MM-DD`

```{r}
getAggregates <- function(search, multiplier = 1, 
                          timespan = c("day", "week", 
                                       "month", "quarter", "year"),
                          from, to) {
  # Storage for options to be passed to the API
  timespan <- match.arg(timespan)
  
  # Retrieve the proper ticker for the search query
  ticker <- getTickers(search)
  
  path = paste("/v2/aggs/ticker",
                               ticker, "range", multiplier, timespan, 
                               from, to,
                               sep = "/")
  
  # Retrieve the aggregates information on the ticker
  output <- getFromJSON(path = paste("/v2/aggs/ticker",
                               ticker, "range", multiplier, timespan, 
                               from, to,
                               sep = "/")) %>% 
    as_tibble() %>% 
    select(ticker, results) %>% 
    unnest(results)
  
  # Convert timestamp into a date
  output$t <- as_datetime(output$t/1000) %>% as_date()
  
  return(output)
}
```

## Exploratory Data Analysis

Let's compare Microsoft to Apple.

```{r}
# Microsoft and Apple
msft <- getAggregates("msft", from = "2021-01-01", to = "2021-12-31") %>%
  add_column(name = getTickerName("msft"))
apple <- getAggregates("aapl", from = "2021-01-01", to = "2021-12-31") %>%
  add_column(name = getTickerName("aapl"))

# Combine data frames and add new variable
year <- bind_rows(msft, apple) 

year <- mutate(year, gain = (c / o)*100-100)
```

### Gain correlation

```{r}
gain_wider <- year %>% select(name, gain) %>%
  pivot_wider(names_from = name, values_from = gain) %>%
  unnest()

ggplot(gain_wider, aes(x = `Microsoft Corp`, y = `Apple Inc.`)) + 
  geom_point() +
  geom_smooth(method=lm, se=FALSE) + 
  labs(title = "Correlation Graph")
```

As we can see, the two are positively correlated with `r round(cor(gain_wider["Microsoft Corp"], gain_wider["Apple Inc."])*100, 0)`% correlation.

### Contengency table

NEEDED

### Histogram

```{r}
g <- ggplot(year)

g + aes(x = n) + 
  geom_histogram() +
  geom_density() +
  facet_grid(~name) +
  labs(title = "Histogram of number of transactions per day")
```

### Boxplot

NEEDS FIXING

```{r}
g + aes(x = n) + 
  coord_flip() +
  geom_boxplot() +
  facet_grid(~name) +
  labs(title = "Boxplot of number of transactions per day")
```

### Line

```{r}
g + aes(x = t, y = c) + 
  geom_line() +
  facet_grid(~name) +
  labs(title = "Closing price over 2021",
       x = "Date", y = "Closing Price")
```